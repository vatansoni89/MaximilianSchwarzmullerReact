create react app:
  create-react-app react-complete-guide --scripts-version 1.1.5
  cd react-complete-guide
  npm start

public
  index.html
    <div id="root"></div>
      our code will be injected here.

jsx restrictions:
  only one root html element.
  use className for css class (instaed of class)

component creating approach:
  create class with importing React, {Component} and extend Component class. (Like App)
  create function  which return some jsx (html)
        
import React:
  reactCreateElement:  jsx syntex need to be transformed to reactCreateElement and for that we need to import React.

import component:
  always give name starting from upper case. (import Person from "./Person/Person.js";)  

/***

Components & JSX Cheat Sheet
Components are the core building block of React apps. Actually, React really is just a library for creating components in its core.

A typical React app therefore could be depicted as a component tree - having one root component ("App") and then an potentially infinite amount of nested child components.

Each component needs to return/ render some JSX code - it defines which HTML code React should render to the real DOM in the end.

JSX is NOT HTML but it looks a lot like it. Differences can be seen when looking closely though (for example className in JSX vs class in "normal HTML"). JSX is just syntactic sugar for JavaScript, allowing you to write HTMLish code instead of nested React.createElement(...) calls.

When creating components, you have the choice between two different ways:

Functional components (also referred to as "presentational", "dumb" or "stateless" components - more about this later in the course) => const cmp = () => { return <div>some JSX</div> } (using ES6 arrow functions as shown here is recommended but optional)
class-based components (also referred to as "containers", "smart" or "stateful" components) => class Cmp extends Component { render () { return <div>some JSX</div> } } 
We'll of course dive into the difference throughout this course, you can already note that you should use 1) as often as possible though. It's the best-practice.

***/  

component benefit:
  reusable: define once use multiple time.
  custom html component.

state:
  its a special property. (reserved word. )
  only available in class which extends component.
  if it changes it will lead react to update the dom and re-render.

switchNameHandler:
  don't add () in button onClick prop.  

ReactHook:
  use:
    useState({})
      [0]: state object
      [1]: fun to change state object, and it replaces the old with new. If old hv 2 props and new have 1 then both will be replaced by 1. To avoid it use replacing specific prop {specificProp: value}

container or Stateful or Smart component are same.      

click={() => this.switchNameHandler("By-Function-Call")}
  () => this.switchNameHandler("By-Function-Call")
    It returns function call, and executes on click only (not immediate)
      This can be in-efficient.

.net core 3: https://www.youtube.com/watch?v=W8yL8vRnUnA

don't mutate the original state, create and copy and update and set that.

list
  key: need to be unique, need not to be a number.

nameChangedHandler with 2way binding:
  Get person by id and update copy of that. Then create copy of list and update this person there and set state again.